(define not  (lambda (a)    (equal? a #f)))(define not2  (lambda (a)    (cond      [a #f]      [else #t])))(define xor  (lambda (a b)    (cond      [a (not b)]      [else b])))(define inor  (lambda (a b)    (cond      [a #t]      [else b])))(define nor  (lambda (a b)    (cond      [a #f]      [else b])))(define and2  (lambda (a b)    (cond      [a #f]      [else (not b)])))(define nand  (lambda (a b)    (cond      [a (not b)]      [else #f])))(define iff  (lambda (a b)    (cond      [a b]      [else (not b)])))(define imp  (lambda (a b)    (cond      [a b]      [else #t])))(define second   (lambda (p) (first (rest p))))(define third  (lambda (p) (first (rest (rest p)))))(define secons  (lambda (r s)    (cons (second r) s)))(define L  (lambda (a b)    (cond      [(atom? b) (first a)]      [else (rest a)])))(define atombomb  (lambda (a b)    (cond      [(equal? (equal? (atom? a) (atom? b)) #t) (cons a (cons b '()))]      [(atom? a) (cons a b)]      [(atom? b) (cons b a)]      [else (cons b a)])))(define heads  (lambda (a b)    (cond      [(both-null? a b) '()]      [else (heads-help1 a b)])))(define both-null?  (lambda (a b)    (and2 (null? a) (null? b))))(define heads-help1  (lambda (a b)    (cond      [(both-non-null? a b) (heads-combine a b)]      [else (heads-help2 a b)])))(define both-non-null?  (lambda (a b)    (nor (null? a) (null? b))))(define heads-combine  (lambda (a b)    (cons (first a) (cons (first b) '()))))(define heads-help2  (lambda (a b)    (cond      [(null? a) (first b)]      [else (first a)])))(define atom-or-list  (lambda (a)    (cond      [(atom? a) 'atom]      [else 'list])))(define lat?  (lambda (a)    (cond      [(null? a) #t]      [(atom? (first a)) (lat? (rest a))]      [else #f])))(define member?  (lambda (a s)    (cond      [(null? s) #f]      [(equal? (first s) a) #t]      [else (member? a (rest s))])))(define lili?  (lambda (a)    (cond      [(null? a) #t]      [(atom? (first a)) #f]      [else (lili? (rest a))])))(define atomic?  (lambda (a)    (cond      [(atom? a) #t]      [(null? a) #t]      [else #f])))(define non-atomic?  (lambda (a)    (cond      [(null? a) #t]      [(not (atomic? (first a))) (non-atomic? (rest a))]      [else #f])))(define latel?  (lambda (a)    (cond      [(null? a) #t]      [(atomic? (first a)) (latel? (rest a))]      [else #f])))(define eqlat?  (lambda (a b)    (cond      [(null? a) a]      [else #f                                   ])))      (define rember  (lambda (a s)    (cond      [(null? s) '()]      [(equal? (first s) a) (rest s)]      [else (cons (first s) (rember a (rest s)))])))(define getfirsts  (lambda (s)    (cond      [(null? s) '()]      [else (cons (first s)(getfirsts (rest s)))])))(define  dupla  (lambda (a s)    (cond      [(null? s) '()]      [else (cons a (dupla a (rest s)))])))(define double  (lambda (a s)    (cond      [(null? s) '()]      [(equal? (first s) a) (cons a s)]      [else (cons (first s) (double a (rest s)))])))(define insert1  (lambda (a b s)    (cond      [(null? s) '()]      [(equal? (first s) a) (cons b s)]      [else (cons (first s) (insert1 a b (rest s)))])))(define less?      (lambda (m n)        (cond          [(equal? m n) #f]          [(zero? m) #t]          [(zero? n) #f]          [else (less? (sub1 m) (sub1 n))])))(define next-please     (lambda (n)        (next-please-help n (max-num n))))(define next-pleas-help     (lambda (nums biggest) (cons biggest (rember biggest nums))))(define max-num      (lambda (n) (max-num-help n 0)))(define max-num-help     (lambda (nums acc)       (cond         [(null? nums) acc]         [(less? acc (first nums)) (max-num-help (rest nums) (first nums))]         [else (max-num-help (rest nums) acc)])))(define make-leaf  (lambda (a)    (cons a (cons '() (cons '() '())))))(define leaf?  (lambda (a)    (cond      [(not (null? (rest a))) #f]      [(not (null? (rest (rest a)))) #f]      [else #t])))(define switch-subtrees  (lambda (a)    (cons (first a) (cons (rest (rest a)) (rest a)))))(define replace-root  (lambda (a v)    (cons v (cons (rest a) (cons (rest (rest a)))))))(define replace-left-tree  (lambda (trA trB)    (cons (first trA) (cons (first (rest trB)) (rest (rest (trA)))))))(define replace-right-tree  (lambda (trA trB)    (cons (first trA) (cons (first (rest trA)) (rest (rest (trB)))))))(define selection-sort  (lambda (n)    (cond      [(null? n) '()]      [else (cons (first (n-p n)) (selection-sort (rest (first (n-p n)))))])))(define fib  (lambda (n)    (fib-help n 0 1)))(define fib-help  (lambda (a b c)    (cond      [(zero? a) b]      [else (fib-help (- a 1) c (+ b c))])))(define tree-insert  (lambda (a obt)    (cond      [(null? obt) (make-leaf a)]      [(order? a (root obt))       (replace-left-tree         obt (tree-insert a (left-tree obt)))]      [else (replace-right-tree              obt              (tree-insert a (right-tree obt)))])))(define order?  (lambda (a b)    (order?-help (explode a) (explode b))))(define order?-help  (lambda (r s)    (cond       [(null? r) r])))    